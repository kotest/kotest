package io.kotest.runner.junit5

import io.kotest.Project
import io.kotest.core.*
import io.kotest.core.spec.SpecConfiguration
import io.kotest.fp.Try
import io.kotest.runner.jvm.TestEngineListener
import org.junit.platform.engine.*
import org.junit.platform.engine.support.descriptor.AbstractTestDescriptor
import org.junit.platform.engine.support.descriptor.ClassSource
import org.junit.platform.engine.support.descriptor.EngineDescriptor
import org.slf4j.LoggerFactory
import java.nio.file.Files
import java.nio.file.Paths
import kotlin.reflect.KClass

/**
 * Notifies JUnit Platform of test statuses via a [EngineExecutionListener].
 *
 * JUnit platform supports out of order notification of tests, in that sibling
 * tests can be executing in parallel and updating JUnit out of order. However the gradle test
 * task gets confused if we are executing two or more tests directly under the root at once.
 * Therefore we must queue up notifications until each spec is completed.
 *
 * Gradle test run observations:
 *
 * using Platform 1.6.0 --
 * TestDescriptor.Type.CONTAINER seem to be ignored in output.
 * TestDescriptor.Type.CONTAINER_AND_TEST appear as siblings of their nested tests if not added as a child
 * Add child first, then register dynamic test, then start the test
 *
 * Top level descriptors must have a source attached or the execution will fail with a parent attached exception.
 * Type.CONTAINER_TEST doesn't seem to work as a top level descriptor, it will hang
 * leaf tests do not need to be completed but they will be marked as uncomplete in intellij.
 * Dynamic test can be called after or before addChild.
 * A Type.TEST can be a child of a Type.TEST.
 * Intermediate Type.CONTAINER seem to be ignored in output.
 * Intermediate containers can have same class source as parent.
 * Type.TEST as top level seems to hang.
 * A TEST doesn't seem to be able to have the same source as a parent, or hang.
 * A TEST seems to hang if it has a ClassSource.
 * MethodSource seems to be ok with a TEST.
 * Container test names seem to be taken from a Source.
 * Nested tests are outputted as siblings.
 * Can complete executions out of order.
 * Child failures will fail parent CONTAINER.
 * Sibling containers can start and finish in parallel.
 *
 * Intellij runner observations:
 *
 * Intermediate Type.CONTAINERs are shown.
 * Intermediate Type.TESTs are shown.
 * A Type.TEST can be a child of a Type.TEST
 * MethodSource seems to be ok with a TEST.
 * Container test names seem to be taken from the name property.
 * Nested tests are outputted as nested.
 * Child failures will not fail containing TEST.
 * child failures will fail a containing CONTAINER.
 * Call addChild _before_ registering test otherwise will appear in the display out of order.
 * Must start tests after their parent or they can go missing.
 * Sibling containers can start and finish in parallel.
 */
class JUnitTestRunnerListener(
   private val listener: EngineExecutionListener,
   val root: EngineDescriptor
) : TestEngineListener {

   private val logger = LoggerFactory.getLogger(this.javaClass)

   data class ResultState(val testCase: TestCase, val result: TestResult)

   // contains a mapping of a Description to a junit TestDescription, so we can look up the parent
   // when we need to register a new test
   private val descriptors = mutableMapOf<Description, TestDescriptor>()

   // contains every test that was discovered but not necessarily executed
   private val discovered = linkedSetOf<Pair<Description, TestType>>()

   // contains a set of all the tests we have notified as started, to avoid
   // double notification when a test is set to run multiple times
   private val started = mutableSetOf<Description>()

   // contains all the results generated by tests in this spec
   // we store them all and mark the tests as finished only when we exit the spec
   private val results = mutableSetOf<ResultState>()

   private var specException: Throwable? = null

   override fun engineStarted(classes: List<KClass<out SpecConfiguration>>) {
      logger.trace("Engine started; classes=[$classes]")
      listener.executionStarted(root)
   }

   override fun engineFinished(t: Throwable?) {
      logger.trace("Engine finished; throwable=[$t]")

      val failures = results
         .filter { it.result.status == TestStatus.Failure || it.result.status == TestStatus.Error }

      if (Project.writeSpecFailureFile())
         writeSpecFailures(failures)

      fun hasIgnored() = results.any { it.result.status == TestStatus.Ignored }

      val result = when {
         t != null -> TestExecutionResult.failed(t)
         Project.failOnIgnoredTests && hasIgnored() -> TestExecutionResult.failed(RuntimeException("Build contained ignored test"))
         else -> TestExecutionResult.successful()
      }

      logger.trace("Notifying junit that root descriptor completed $root")
      // we are ignoring junit guidelines here and failing the engine if anything failed
      // this is because in gradle and intellij nested errors are not very obvious,
      // plus, if 1 or more tests failed, then the engine didn't really pass imo
      listener.executionFinished(root, result)
   }

   private fun writeSpecFailures(failures: List<ResultState>): Try<Any> = Try {
      val dir = Paths.get(".kotest")
      dir.toFile().mkdirs()
      val path = dir.resolve("spec_failures").toAbsolutePath()
      logger.trace("Writing report to $path")
      val content = failures.map { it.testCase.spec.javaClass.canonicalName }.distinct().joinToString("\n")
      Files.write(path, content.toByteArray())
   }

   override fun specStarted(kclass: KClass<out SpecConfiguration>) {
      logger.trace("beforeSpecClass [${kclass.qualifiedName}]")
      try {
         val descriptor = createSpecDescriptor(kclass)
         logger.trace("Registering junit dynamic test: $descriptor")
         listener.dynamicTestRegistered(descriptor)
         logger.trace("Notifying junit that execution has started: $descriptor")
         listener.executionStarted(descriptor)
      } catch (t: Throwable) {
         logger.error("Error in JUnit Platform listener", t)
         specException = t
      }
   }

   override fun specFinished(
      klass: KClass<out SpecConfiguration>,
      t: Throwable?,
      results: Map<TestCase, TestResult>
   ) {
      logger.trace("specFinished [$klass]")
      val descriptor = descriptors[klass.description()]
         ?: throw RuntimeException("Error retrieving description for spec: ${klass.qualifiedName}")
      val result = if (specException == null)
         TestExecutionResult.successful()
      else
         TestExecutionResult.failed(specException)
      logger.trace("Notifying junit that execution has finished: $descriptor, $result")
      listener.executionFinished(descriptor, result)
   }

   override fun testStarted(testCase: TestCase) {
      val descriptor = createTestDescriptor(testCase)
      logger.trace("Registering junit dynamic test: $descriptor")
      listener.dynamicTestRegistered(descriptor)
      logger.trace("Notifying junit that execution has started: $descriptor")
      listener.executionStarted(descriptor)
   }

   override fun testFinished(testCase: TestCase, result: TestResult) {
      val descriptor = descriptors[testCase.description]
         ?: throw RuntimeException("Error retrieving description for: ${testCase.description}")
      logger.trace("Notifying junit that execution has finished: $descriptor")
      listener.executionFinished(descriptor, result.testExecutionResult())
   }

   override fun testIgnored(testCase: TestCase, reason: String?) {
      val descriptor = createTestDescriptor(testCase)
      listener.dynamicTestRegistered(descriptor)
      listener.executionSkipped(descriptor, reason)
   }

   private fun TestResult.testExecutionResult(): TestExecutionResult = when (this.status) {
      TestStatus.Ignored -> error("An ignored test cannot reach this state")
      TestStatus.Success -> TestExecutionResult.successful()
      TestStatus.Error -> TestExecutionResult.aborted(this.error)
      TestStatus.Failure -> TestExecutionResult.failed(this.error)
   }

   /**
    * Creates a new [TestDescriptor] appended to the receiver, adds it as a child of the receiver,
    * and registers it with the descriptors set.
    */
   private fun TestDescriptor.append(
      description: Description,
      type: TestDescriptor.Type,
      source: TestSource?
   ): TestDescriptor {
      val segment = if (description.isSpec()) "spec" else "test"
      val descriptor =
         object : AbstractTestDescriptor(this.uniqueId.append(segment, description.name), description.name, source) {
            override fun getType(): TestDescriptor.Type = type
            override fun mayRegisterTests(): Boolean = TestDescriptor.Type.CONTAINER_AND_TEST == type
         }
      this.addChild(descriptor)
      descriptors[description] = descriptor
      return descriptor
   }

   private fun createSpecDescriptor(klass: KClass<out SpecConfiguration>): TestDescriptor {
      val source = ClassSource.from(klass.java)
      return root.append(klass.description(), TestDescriptor.Type.CONTAINER_AND_TEST, source)
   }

   private fun createTestDescriptor(testCase: TestCase): TestDescriptor {
      val parent = descriptors[testCase.description.parent()]
      if (parent == null) {
         val msg = "Cannot find parent description for: ${testCase.description}"
         logger.error(msg)
         error(msg)
      }
      // there is a bug in gradle 4.7+ whereby CONTAINER_AND_TEST breaks test reporting, as it is not handled
      // see https://github.com/gradle/gradle/issues/4912
      // so we can't use CONTAINER_AND_TEST for our test scopes, but simply container
      val type = when (testCase.type) {
         TestType.Container -> TestDescriptor.Type.CONTAINER_AND_TEST
         TestType.Test -> TestDescriptor.Type.TEST
      }
      return parent.append(testCase.description, type, null)
   }

//      val description = klass.description()
//
//      // we should have a result for at least every test that was discovered
//      // we wait until the spec is completed before completing all child scopes, because we need
//      // to wait until all possible invocations of each scope have completed.
//      // for each description we can grab the best result and use that
//      discovered
//         .filter { description.isAncestorOf(it.first) }
//         .forEach {
//            val descriptor = descriptors.getOrPut(it.first) { createTestCaseDescriptor(it.first, it.second) }
//            // find an error by priority
//            val result = findResultFor(it.first)
//            if (result == null) {
//               logger.error("Could not find result for $it")
//               throw RuntimeException("Every description must have a result but could not find one for $it")
//            } else {
//               logger.trace("Notifying junit of test case completion ${descriptor.uniqueId}=$result")
//               try {
//                  when (result.status) {
//                     TestStatus.Success -> listener.executionFinished(descriptor, TestExecutionResult.successful())
//                     TestStatus.Error, TestStatus.Failure -> listener.executionFinished(
//                        descriptor,
//                        TestExecutionResult.failed(result.error)
//                     )
//                     TestStatus.Ignored -> {
//                        if (started.contains(it.first))
//                           throw RuntimeException("A skipped test should never have been started")
//                        listener.executionSkipped(descriptor, result.reason ?: "No reason given")
//                     }
//                  }
//               } catch (t: Throwable) {
//                  logger.error("Error in JUnit Platform listener", t)
//                  throw t
//               }
//            }
//         }
//
//      // now we can complete the spec
//      val descriptor = descriptors[description]
//      if (descriptor == null) {
//         logger.error("Spec descriptor cannot be null $description")
//         throw RuntimeException("Spec descriptor cannot be null")
//      } else {
//         val result = when (t) {
//            null -> TestExecutionResult.successful()
//            else -> TestExecutionResult.failed(t)
//         }
//         logger.trace("Notifying junit that spec finished ${descriptor.uniqueId} $result")
//         listener.executionFinished(descriptor, result)
//      }

   // returns the most important result for a given description
   // by searching all the results stored for that description in order of importance
   private fun findResultFor(description: Description): TestResult? {

      // returns any results with the given status, for both ancestors and the test itself
      fun findByStatus(status: TestStatus): TestResult? = results
         .filter { it.testCase.description == description || description.isAncestorOf(it.testCase.description) }
         .filter { it.result.status == status }
         // the lowest level test should be what we pick
         .sortedBy { it.testCase.description.depth() }
         .reversed()
         .map { it.result }
         .firstOrNull()

      var result = findByStatus(TestStatus.Error)
      if (result == null)
         result = findByStatus(TestStatus.Failure)
      if (result == null)
         result = findByStatus(TestStatus.Success)
      if (result == null)
         result = findByStatus(TestStatus.Ignored)
      return result
   }
}

fun UniqueId.appendSpec(description: Description) = this.append("spec", description.name)!!
