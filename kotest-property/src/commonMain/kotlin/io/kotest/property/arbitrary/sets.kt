package io.kotest.property.arbitrary

import io.kotest.property.Arb
import io.kotest.property.Gen
import io.kotest.property.PropertyTesting
import io.kotest.property.Shrinker
import kotlin.jvm.JvmOverloads
import kotlin.random.nextInt
import kotlin.ranges.IntRange

/**
 * Returns an [Arb] whose of values are a set of values generated by the given element generator [gen].
 * The size of the set is specified by the [size] parameter.
 *
 * Note: This may fail to terminate if the element generator cannot produce a large enough number of
 * unique items to satify the required set size
 *
 * @param gen the generator of values to populate each set
 * @param size the number of values to generate in the set
 * @param slippage when generating values, we may have repeats if the underlying gen is random.
 *        The slippage factor determines how many times we continue after retreiving a duplicate value.
 *        The total acceptable number of misses is the slippage factor multipled by the target set size.
 *        If this value is not specified (null) then the slippage value will be 10.
 */
fun <A> Arb.Companion.set(gen: Gen<A>, size: Int, slippage: Int = 10): Arb<Set<A>> = set(gen, size..size, slippage)

/**
 * Returns an [Arb] whose of values are a set of values generated by the given element generator [gen].
 * The size of each set is determined randomly within the specified [range].
 *
 * Note: This may fail to terminate if the element generator cannot produce a large enough number of
 * unique items to satify the required set size
 *
 * @param gen the generator of values to populate each set
 * @param range each set will have a random size within this given range
 * @param slippage when generating values, we may have repeats if the underlying gen is random.
 *        The slippage factor determines how many times we continue after retreiving a duplicate value.
 *        The total acceptable number of misses is the slippage factor multipled by the target set size.
 *        If this value is not specified (null) then the slippage value will be 10.
 */
@JvmOverloads
fun <A> Arb.Companion.set(gen: Gen<A>, range: IntRange = PropertyTesting.defaultCollectionsRange, slippage: Int = 10): Arb<Set<A>> {
   check(!range.isEmpty())
   check(range.first >= 0)
   return arbitrary(SetShrinker(range)) {
      val genIter = gen.generate(it).iterator()
      val targetSize = it.random.nextInt(range)
      var iterations = 0
      val maxMisses = targetSize * slippage
      val elements: Sequence<A> = genIter.asSequence().map { sample-> sample.value }
      // We may generate duplicates, but we don't know if the underlying gen has sufficient cardinality
      // to satisfy our range, so we can try for a while, but must not try forever.
      // The slippage factor controls how many times we will accept a non unique element before giving up,
      // which is the number of elements in the target set * slippage
      val set = takeSet(elements, targetSize, maxMisses)
      check(set.size == targetSize) {
         "the target size requirement of $targetSize could not be satisfied after $iterations consecutive samples"
      }
      set
   }
}

internal fun<A> takeSet(elements: Sequence<A>, targetSize: Int, maxMisses: Int): Set<A> {
   var elementsTaken = 0
   val chunk = elements
      .takeWhile { elementsTaken++ < maxMisses }
      .distinct()
      .take(targetSize)
   return chunk.toSet()
}

/**
 * A Shrinker for sets, utilizing the ListShrinker.
 */
class SetShrinker<A>(private val range: IntRange) : Shrinker<Set<A>> {
   val listShrinker = ListShrinker<A>(range)

   override fun shrink(value: Set<A>): List<Set<A>> =
      listShrinker.shrink(value.toList())
         .map { it.toSet() }
}
