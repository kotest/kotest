package io.kotest.framework.gradle.tasks

import io.kotest.framework.gradle.IntellijUtils
import org.gradle.api.provider.Property
import org.gradle.api.tasks.CacheableTask
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.TaskAction
import org.gradle.process.ExecOperations
import java.nio.file.Paths
import javax.inject.Inject
import kotlin.io.path.exists

// gradle requires the class be extendable
@CacheableTask // this allows gradle to cache our inputs
abstract class KotestJsTask @Inject internal constructor(
   private val executors: ExecOperations,
) : AbstractKotestTask() {

   companion object {

      // this is the name of the generated function from the KSP plugin
      // it should always match whatever the plugin is generating
      private const val KOTEST_RUN_FN_NAME = "runKotest"

      // this is the name of the package where the KSP plugin places the generated top level run function
      // it should always match whatever the plugin is generating
      private const val KOTEST_JS_GENERATED_PACKAGE = "io.kotest.framework.runtime.js"

      // the value used to specify the team city format
      private const val LISTENER_TC = "teamcity"
      private const val LISTENER_CONSOLE = "console"
   }

   /**
    * This is the javascript file generated by the kotlin js compiler for subprojects
    */
   @get:Input
   abstract val compileSyncPath: Property<String>

   @get:Input
   abstract val nodeExecutable: Property<String>

   @TaskAction
   protected fun execute() {
      if (!Paths.get(compileSyncPath.get()).exists()) return

      executors.exec {

         // for the test framework setup in KotlinJsTest see KotlinMocha as well and KotlinJsTestFramework

         // see TCServiceMessagesTestExecutor for how kotlin.test does it
//         exec.workingDir = spec.processLaunchOptions.workingDir.orNull?.asFile
//         exec.environment(spec.processLaunchOptions.environment.orNull.orEmpty())
//         exec.executable = spec.processLaunchOptions.executable.get()
//         exec.args = spec.processArgs
//         exec.standardOutput = TCServiceMessageOutputStreamHandler(
//            client,
//            { spec.showSuppressedOutput() },
//            log,
//            ignoreTcsmOverflow,
//         )
//         exec.errorOutput = TCServiceMessageOutputStreamHandler(
//            client,
//            { spec.showSuppressedOutput() },
//            log,
//            ignoreTcsmOverflow,
//         )

         val includeArg = if (include.orNull == null) null else "'${include.get()}'"
         val listenerArg = if (IntellijUtils.isIntellij()) LISTENER_TC else LISTENER_CONSOLE
         val testReportsDirArg = testReportsDir.get().asFile.absolutePath

         // this is the entry point passed to node which references the well defined runKotest function
         val nodeCommand =
            "require('${compileSyncPath.get()}').$KOTEST_JS_GENERATED_PACKAGE.$KOTEST_RUN_FN_NAME('$listenerArg', $includeArg, '$testReportsDirArg')"
         println("Node command :$nodeCommand")

         // similar to setting executable + args separately
         commandLine(nodeExecutable.get(), "-e", nodeCommand)
      }
   }
}
