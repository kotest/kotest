"use strict";(self.webpackChunkkotestdocs=self.webpackChunkkotestdocs||[]).push([[85532],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>p});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),s=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=s(e.components);return r.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),m=s(n),p=a,h=m["".concat(c,".").concat(p)]||m[p]||d[p]||o;return n?r.createElement(h,l(l({ref:t},u),{},{components:n})):r.createElement(h,l({ref:t},u))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,l=new Array(o);l[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,l[1]=i;for(var s=2;s<o;s++)l[s]=n[s];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},54980:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>s});var r=n(87462),a=(n(67294),n(3905));const o={title:"Reproduce Race Conditions",slug:"race_conditions.html"},l=void 0,i={unversionedId:"framework/race_conditions",id:"framework/race_conditions",title:"Reproduce Race Conditions",description:"A simple tool to reproduce some common race conditions such as deadlocks in automated tests.",source:"@site/docs/framework/race_conditions.md",sourceDirName:"framework",slug:"/framework/race_conditions.html",permalink:"/docs/next/framework/race_conditions.html",draft:!1,editUrl:"https://github.com/kotest/kotest/blob/master/documentation/docs/framework/race_conditions.md",tags:[],version:"current",frontMatter:{title:"Reproduce Race Conditions",slug:"race_conditions.html"},sidebar:"framework",previous:{title:"Fake Functions",permalink:"/docs/next/framework/fakery.html"},next:{title:"Test Output",permalink:"/docs/next/framework/test_output.html"}},c={},s=[],u={toc:s};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"A simple tool to reproduce some common race conditions such as deadlocks in automated tests.\nWhenever multiple coroutines or threads mutate shared state, there is a possibility of race conditions.\nIn many common cases this tool allows to reproduce them easily."),(0,a.kt)("br",null),"Suppose, for example, that two threads or coroutins are acquiring exclusive locks on the same two resources in different order:",(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Thread 1"),(0,a.kt)("th",{parentName:"tr",align:null},"Thread 2"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Lock Resource A"),(0,a.kt)("td",{parentName:"tr",align:null},"Lock Resource B")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Lock Resource B"),(0,a.kt)("td",{parentName:"tr",align:null},"Lock Resource A")))),(0,a.kt)("p",null,"If we are continuously running these two functions in parallel, eventually there should be deadlocks, but we don't know when exactly. With the help of ",(0,a.kt)("inlineCode",{parentName:"p"},"runInParallel")," we can reliably reproduce the deadlock every time we run the following code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"  runInParallel({ runner: ParallelRunner ->\n    lockResourceA()\n    runner.await()\n    lockResourceB()\n  },\n    { runner: ParallelRunner ->\n      lockResourceB()\n      runner.await()\n      lockResourceA()\n    }\n  )\n")),(0,a.kt)("p",null,"Let's discuss a few more advanced scenarios where reproducing race conditions comes very handy."),(0,a.kt)("br",null),"Suppose, for instance, that the following code runs without any synchronization concurrently:",(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"if(canRunTask()) {\n    runTask()\n}\n")),(0,a.kt)("p",null,"Without concurrency, this code will always run correctly. Let us reproduce concurrency as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'   private data class Box(val maxCapacity: Int) {\n      private val items = mutableListOf<String>()\n\n      fun addItem(item: String) = items.add(item)\n\n      fun hasCapacity() = items.size < maxCapacity\n\n      fun items() = items.toList()\n   }\n\n(snip)\n\n"two tasks share one mutable state, both make the same decision at the same time" {\n  val box = Box(maxCapacity = 2)\n  box.addItem("apple")\n  runInParallel({ runner: ParallelRunner ->\n    val hasCapacity = box.hasCapacity()\n    runner.await()\n    if(hasCapacity) {\n      box.addItem("banana")\n    }\n  },\n    { runner: ParallelRunner ->\n      val hasCapacity = box.hasCapacity()\n      runner.await()\n      if(hasCapacity) {\n        box.addItem("orange")\n      }\n    }\n  )\n  // capacity is exceeded as a result of race condition\n  box.items() shouldContainExactlyInAnyOrder listOf("apple", "banana", "orange")\n}\n\n')),(0,a.kt)("p",null,"For another example, suppose that we need to reproduce a deadlock between two threads that are trying to modify two Postgres tables in different order."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Orders"),(0,a.kt)("th",{parentName:"tr",align:null},"Items"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Thread 1"),(0,a.kt)("td",{parentName:"tr",align:null},"Thread 2")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Lock Order 1"),(0,a.kt)("td",{parentName:"tr",align:null})),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null}),(0,a.kt)("td",{parentName:"tr",align:null},"Lock Item 2")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Lock Item 2"),(0,a.kt)("td",{parentName:"tr",align:null})),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null}),(0,a.kt)("td",{parentName:"tr",align:null},"Lock Order 1")))),(0,a.kt)("p",null,"A brute force approach would be to run this scenario many times, hoping that eventually we shall reproduce the deadlock. Eventually this should work, but we shall have to spend some time setting up the test, and we might have to wait until it does reproduce."),(0,a.kt)("br",null),(0,a.kt)("br",null),"Kotest's `runInParallel` makes the task much easier, and the deadlock is reproduced on the first attempt. The following code shows how to do this, assuming that `executeSql` function is implemented and does execute SQL. Both threads do the following: * begin a transaction * update one table * wait for the other thread to complete its first update * try to update the other table",(0,a.kt)("p",null,"This is a textbook scenario of a deadlock, and it is reliably reproduced every time we run this code. All the busywork of setting up threads and synchronizing them is handled by ",(0,a.kt)("inlineCode",{parentName:"p"},"runInParallel"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'// Prerequisites:\nexecuteSql(\n  "DROP TABLE IF EXISTS test0",\n  "DROP TABLE IF EXISTS test1",\n  "SELECT 1 AS id, \'green\' AS color INTO test0",\n  "SELECT 1 AS id, \'yellow\' AS color INTO test1",\n)\n\n// reproduce a deadlock\n\nvar successCount = 0\nvar thrownExceptions = mutableListOf<Throwable>()\nrunInParallel(\n  { runner ->\n    try {\n      executeSql(jdbi, "UPDATE test0 SET color = \'blue\' WHERE id = 1")\n      jdbi.useTransaction<Exception> { handle ->\n        handle.execute("UPDATE test0 SET color = \'blue\' WHERE id = 1")\n        runner.await() // wait for the other thread to do its thing\n        handle.execute("UPDATE test1 SET color = \'purple\' WHERE id = 1")\n        successCount++\n      }\n    } catch (ex: Throwable) {\n      thrownExceptions.add(ex)\n    }\n  },\n  { runner ->\n    try {\n      jdbi.useTransaction<Exception> { handle ->\n        handle.execute("UPDATE test1 SET color = \'blue\' WHERE id = 1")\n        runner.await() // wait for the other thread to do its thing\n        handle.execute("UPDATE test0 SET color = \'purple\' WHERE id = 1")\n        successCount++\n      }\n    } catch (ex: Throwable) {\n      thrownExceptions.add(ex)\n    }\n  }\n)\nsuccessCount shouldBe 1\nthrownExceptions shouldHaveSize 1\nisDeadlock(thrownExceptions[0]) shouldBe true\n\n')),(0,a.kt)("br",null),"Finally, let's use `parallelRunner` to demostrate that mocking a static function such as `LocalDateTime.now()` in one test can affect completely different tests running in parallel:",(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'runInParallel(\n{ runner: ParallelRunner ->\n    timedPrint("Before mock on same thread: ${LocalDateTime.now().toString()}")\n    runner.await()\n    mockkStatic(LocalDateTime::class)\n    val localTime = LocalDateTime.of(2022, 4, 27, 12, 34, 56)\n    every { LocalDateTime.now(any<Clock>()) } returns localTime\n    runner.await()\n    timedPrint("After mock on same thread: ${LocalDateTime.now().toString()}")\n},\n{ runner: ParallelRunner ->\n        timedPrint("Before mock on other thread: ${LocalDateTime.now().toString()}")\n        runner.await()\n        runner.await()\n        timedPrint("After mock on other thread: ${LocalDateTime.now().toString()}")\n    }\n)\n\n// the output from both threads shows the same mocked output:\n\nTime: 2023-05-12T13:14:07.815923, Thread: 51, Before mock on other thread: 2023-05-12T13:14:07.737748\nTime: 2023-05-12T13:14:07.816011, Thread: 50, Before mock on same thread: 2023-05-12T13:14:07.737736\nTime: 2022-04-27T12:34:56, Thread: 51, After mock on other thread: 2022-04-27T12:34:56\nTime: 2022-04-27T12:34:56, Thread: 50, After mock on same thread: 2022-04-27T12:34:56\n')))}d.isMDXComponent=!0}}]);