"use strict";(self.webpackChunkkotestdocs=self.webpackChunkkotestdocs||[]).push([[97559],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(n),d=r,h=m["".concat(l,".").concat(d)]||m[d]||u[d]||o;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},82272:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(87462),r=(n(67294),n(3905));const o={title:"Should Be",slug:"shouldbe.html"},i=void 0,s={unversionedId:"assertions/shouldbe",id:"assertions/shouldbe",title:"Should Be",description:"The main matcher or assertion in Kotest is the shouldBe matcher. This matcher is used to assert equality between",source:"@site/docs/assertions/shouldbe.md",sourceDirName:"assertions",slug:"/assertions/shouldbe.html",permalink:"/docs/next/assertions/shouldbe.html",draft:!1,editUrl:"https://github.com/kotest/kotest/blob/master/documentation/docs/assertions/shouldbe.md",tags:[],version:"current",frontMatter:{title:"Should Be",slug:"shouldbe.html"},sidebar:"assertions",previous:{title:"Matchers",permalink:"/docs/next/assertions/matchers.html"},next:{title:"Custom Matchers",permalink:"/docs/next/assertions/custom-matchers.html"}},l={},p=[{value:"Custom Eq Instances",id:"custom-eq-instances",level:2}],c={toc:p};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"main")," matcher or assertion in Kotest is the ",(0,r.kt)("inlineCode",{parentName:"p"},"shouldBe")," matcher. This matcher is used to assert ",(0,r.kt)("em",{parentName:"p"},"equality")," between\nan an actual and an expected value. The syntax is in the format ",(0,r.kt)("inlineCode",{parentName:"p"},"actual shouldBe expected")," For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val a = "samuel"\nval b = a.take(3)\nb shouldBe "sam"\n')),(0,r.kt)("p",null,"When two values do not compare equal, Kotest will print out a nice error message including an intellij ",(0,r.kt)("inlineCode",{parentName:"p"},"<click to see\ndifference>")," between the two values. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Expected :world\nActual   :hello\n<Click to see difference>\n")),(0,r.kt)("p",null,"Note, you can check two values are ",(0,r.kt)("em",{parentName:"p"},"not")," equal using ",(0,r.kt)("inlineCode",{parentName:"p"},"shouldNotBe"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val a = "samuel"\nval b = a.take(3)\nb shouldNotBe "bob"\n')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"shouldBe")," matcher can be combined with ",(0,r.kt)("a",{parentName:"p",href:"/docs/next/assertions/power-assert"},"power assert")," for greater effect.")),(0,r.kt)("p",null,"Behind the scenes, Kotest uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"equals")," method but also adds extra logic to determine equality for some types where\nsimple object equality isn't quite appropriate. For example, on the JVM, it is well known that ",(0,r.kt)("inlineCode",{parentName:"p"},"Arrays")," with the same\ncontents will not be considered equal when using the equals method. Another example is primitives of different types\neven with the same value."),(0,r.kt)("p",null,"This logic is encapsulated in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," typeclass which Kotest uses internally. It is also possible to define your own\nequality logic for types by implementing ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," and registering it with Kotest."),(0,r.kt)("h2",{id:"custom-eq-instances"},"Custom Eq Instances"),(0,r.kt)("p",null,"Let's show an example of creating a custom ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," instance for comparing ",(0,r.kt)("inlineCode",{parentName:"p"},"Foo")," objects. Firstly, the definition of ",(0,r.kt)("inlineCode",{parentName:"p"},"Foo"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"data class Foo(val value: String)\n")),(0,r.kt)("p",null,"Then we implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," typeclass for whatever equality logic we want, returning an ",(0,r.kt)("inlineCode",{parentName:"p"},"EqResult")," which is either\n",(0,r.kt)("inlineCode",{parentName:"p"},"Success")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Failure"),"."),(0,r.kt)("p",null,"Here are are saying that if one ",(0,r.kt)("inlineCode",{parentName:"p"},"Foo")," contains the string ",(0,r.kt)("inlineCode",{parentName:"p"},"hello")," and the other contains the string ",(0,r.kt)("inlineCode",{parentName:"p"},"world")," then they\nare equal. To return a failure message we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"AssertionErrorBuilder")," which is a helper to build the\nappropriate concrete ",(0,r.kt)("inlineCode",{parentName:"p"},"AssertionError")," for whichever platform we are running on."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'object FooEq : Eq<Foo> {\n  override fun equals(actual: Foo, expected: Foo, context: EqContext): EqResult {\n    return if (actual.value == "hello" && expected.value == "world")\n      EqResult.Success\n    else EqResult.Failure {\n      AssertionErrorBuilder.create().withMessage("I don\'t like foo").build()\n    }\n  }\n}\n')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"If we specify the ",(0,r.kt)("em",{parentName:"p"},"expected")," and ",(0,r.kt)("em",{parentName:"p"},"actual")," values to the error builder the ",(0,r.kt)("inlineCode",{parentName:"p"},"<click to see difference>")," link will be\nautomatically generated too.")),(0,r.kt)("p",null,"Then we register it with Kotest, specifying the type that we want to use it for. Here we are\nusing ",(0,r.kt)("a",{parentName:"p",href:"/docs/next/framework/project-config.html"},"project config")," to set it up before any tests are run. We could do this at the\nspec level too, but bear in mind if you are running tests in parallel then the registration will be non-deterministic."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"class ProjectConfig : AbstractProjectConfig() {\n  override suspend fun beforeProject() {\n    DefaultEqResolver.register(Foo::class, FooEq)\n  }\n}\n")),(0,r.kt)("p",null,"Finally, we can use our custom ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," instance in our tests by simply using ",(0,r.kt)("inlineCode",{parentName:"p"},"shouldBe")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"shouldNotBe")," as normal."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'test("custom eq should be selected if both sides are the same type") {\n  Foo("hello") shouldBe Foo("world")\n}\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Custom ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," instances are only selected if both sides of the call are the type specified when registered. Also the type\nmust be exact, subclasses are not selected automatically and must also be registered")))}u.isMDXComponent=!0}}]);