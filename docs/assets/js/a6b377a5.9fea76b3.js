"use strict";(self.webpackChunkkotestdocs=self.webpackChunkkotestdocs||[]).push([[14193],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var a=n(67294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var r=a.createContext({}),c=function(e){var t=a.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(r.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,i=e.originalType,r=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),u=l,h=p["".concat(r,".").concat(u)]||p[u]||m[u]||i;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function u(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=n.length,o=new Array(i);o[0]=p;var s={};for(var r in t)hasOwnProperty.call(t,r)&&(s[r]=t[r]);s.originalType=e,s.mdxType="string"==typeof e?e:l,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},26254:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(87462),l=(n(67294),n(3905));const i={id:"field-matching",title:"Matching By Field",slug:"field-matching.html"},o=void 0,s={unversionedId:"assertions/field-matching",id:"assertions/field-matching",title:"Matching By Field",description:"Whenever we want to match only some of the fields, excluding some other fields from comparison, we should use shouldBeEqualUsingFields:",source:"@site/docs/assertions/field-matching.md",sourceDirName:"assertions",slug:"/assertions/field-matching.html",permalink:"/docs/next/assertions/field-matching.html",draft:!1,editUrl:"https://github.com/kotest/kotest/blob/master/documentation/docs/assertions/field-matching.md",tags:[],version:"current",frontMatter:{id:"field-matching",title:"Matching By Field",slug:"field-matching.html"},sidebar:"assertions",previous:{title:"Compiler",permalink:"/docs/next/assertions/compiler-matchers.html"},next:{title:"Jsoup",permalink:"/docs/next/assertions/jsoup-matchers.html"}},r={},c=[{value:"matchBigDecimalsIgnoringScale",id:"matchbigdecimalsignoringscale",level:3},{value:"matchDoublesWithTolerance",id:"matchdoubleswithtolerance",level:3},{value:"matchInstantsWithTolerance",id:"matchinstantswithtolerance",level:3},{value:"matchListsIgnoringOrder",id:"matchlistsignoringorder",level:3},{value:"matchLocalDateTimesWithTolerance",id:"matchlocaldatetimeswithtolerance",level:3},{value:"matchOffsetDateTimesWithTolerance",id:"matchoffsetdatetimeswithtolerance",level:3},{value:"matchStringsIgnoringCase",id:"matchstringsignoringcase",level:3},{value:"matchZonedDateTimesWithTolerance",id:"matchzoneddatetimeswithtolerance",level:3},{value:"Building Your Own Override Matcher",id:"building-your-own-override-matcher",level:2}],d={toc:c};function m(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Whenever we want to match only some of the fields, excluding some other fields from comparison, we should use ",(0,l.kt)("inlineCode",{parentName:"p"},"shouldBeEqualUsingFields"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'   val expected = Thing(name = "apple", createdAt = Instant.now())\n   val actual = Thing(name = "apple", createdAt = Instant.now().plusMillis(42L))\n   actual shouldBeEqualUsingFields {\n      excludedProperties = setOf(Thing::createdAt)\n      expected\n   }\n')),(0,l.kt)("p",null,"Likewise, we can explicitly say which fields to match on, and all other fields will be excluded:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'   val expected = Thing(name = "apple", createdAt = Instant.now())\n   val actual = Thing(name = "apple", createdAt = Instant.now().plusMillis(42L))\n   actual shouldBeEqualUsingFields {\n      includedProperties = setOf(Thing::name)\n      expected\n   }\n')),(0,l.kt)("p",null,"For nested classes, comparison goes recursively, as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'         val doctor1 = Doctor("billy", 23, emptyList())\n         val doctor2 = Doctor("barry", 23, emptyList())\n\n         val city = City("test1", Hospital("test-hospital1", doctor1))\n         val city2 = City("test2", Hospital("test-hospital2", doctor2))\n\n         shouldThrowAny {\n            city.shouldBeEqualUsingFields {\n               city2\n            }\n         }.message shouldContain """Using fields:\n - mainHospital.mainDoctor.age\n - mainHospital.mainDoctor.name\n - mainHospital.name\n - name\n\nFields that differ:\n - mainHospital.mainDoctor.name  =>  expected:<"barry"> but was:<"billy">\n - mainHospital.name  =>  expected:<"test-hospital2"> but was:<"test-hospital1">\n - name  =>  expected:<"test2"> but was:<"test1">"""\n')),(0,l.kt)("p",null,"But we can explicitly stop recursive comparison. In the following example, we are comparing instances of ",(0,l.kt)("inlineCode",{parentName:"p"},"Doctor")," class as a whole, not comparing their individual fields. So the difference in ",(0,l.kt)("inlineCode",{parentName:"p"},"mainHospital.mainDoctor")," is detected, as opposed to detected differences in ",(0,l.kt)("inlineCode",{parentName:"p"},"mainHospital.mainDoctor.name")," in the previous example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'         val doctor1 = Doctor("billy", 22, emptyList())\n         val doctor2 = Doctor("billy", 22, emptyList())\n\n         val city = City("test", Hospital("test-hospital", doctor1))\n         val city2 = City("test", Hospital("test-hospital", doctor2))\n\n         shouldFail {\n            city.shouldBeEqualUsingFields {\n               useDefaultShouldBeForFields = listOf(Doctor::class)\n               city2\n            }\n         }.message shouldContain """Using fields:\n - mainHospital.mainDoctor\n - mainHospital.name\n - name\n\nFields that differ:\n - mainHospital.mainDoctor  =>\n\n')),(0,l.kt)("p",null,"Also we can provide custom matchers for fields. In the following example we are matching ",(0,l.kt)("inlineCode",{parentName:"p"},"SimpleDataClass::name")," as case-insensitive strings:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'     val expected = SimpleDataClass("apple", 1.0, LocalDateTime.now())\n     val actual = expected.copy(name = "Apple")\n     shouldThrow<AssertionError> {\n        actual shouldBeEqualUsingFields expected\n     }.message.shouldContainInOrder(\n        "Fields that differ:",\n        """- name  =>  expected:<"apple"> but was:<"Apple">""",\n     )\n     actual shouldBeEqualUsingFields {\n        overrideMatchers = mapOf(\n           SimpleDataClass::name to matchStringsIgnoringCase\n        )\n        expected\n     }\n')),(0,l.kt)("p",null,"Kotest provides the following override matchers:"),(0,l.kt)("h3",{id:"matchbigdecimalsignoringscale"},"matchBigDecimalsIgnoringScale"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},' val expected = WithManyFields(\n      BigDecimal.ONE,\n      LocalDateTime.now(),\n      ZonedDateTime.now(),\n      OffsetDateTime.now(),\n      Instant.now()\n   )\n val actual = expected.copy(bigDecimal = BigDecimal("1.000"))\n\n actual shouldBeEqualUsingFields {\n    overrideMatchers = mapOf(\n       WithManyFields::bigDecimal to matchBigDecimalsIgnoringScale()\n    )\n    expected\n }\n')),(0,l.kt)("h3",{id:"matchdoubleswithtolerance"},"matchDoublesWithTolerance"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'      val expected = SimpleDataClass("apple", 1.0, LocalDateTime.now())\n      val actual = expected.copy(weight = 1.001)\n\n      actual shouldBeEqualUsingFields {\n         overrideMatchers = mapOf(\n            SimpleDataClass::weight to matchDoublesWithTolerance(0.01)\n         )\n         expected\n      }\n')),(0,l.kt)("h3",{id:"matchinstantswithtolerance"},"matchInstantsWithTolerance"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val expected = WithManyFields(\n      BigDecimal.ONE,\n      LocalDateTime.now(),\n      ZonedDateTime.now(),\n      OffsetDateTime.now(),\n      Instant.now()\n   )\nval actual = expected.copy(instant = expected.instant.plusSeconds(1))\n\nactual shouldBeEqualUsingFields {\n  overrideMatchers = mapOf(\n     WithManyFields::instant to matchInstantsWithTolerance(2.seconds)\n  )\n  expected\n}\n")),(0,l.kt)("h3",{id:"matchlistsignoringorder"},"matchListsIgnoringOrder"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'     val expected = DataClassWithList("name", listOf(1, 2, 3))\n     val actual = expected.copy(elements = listOf(3, 2, 1))\n     actual shouldBeEqualUsingFields {\n        overrideMatchers = mapOf(\n           DataClassWithList::elements to matchListsIgnoringOrder<Int>()\n        )\n        expected\n     }\n')),(0,l.kt)("h3",{id:"matchlocaldatetimeswithtolerance"},"matchLocalDateTimesWithTolerance"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val expected = WithManyFields(\n      BigDecimal.ONE,\n      LocalDateTime.now(),\n      ZonedDateTime.now(),\n      OffsetDateTime.now(),\n      Instant.now()\n   )\nval actual = expected.copy(localDateTime = expected.localDateTime.plusSeconds(1))\n\nactual shouldBeEqualUsingFields {\n  overrideMatchers = mapOf(\n     WithManyFields::localDateTime to matchLocalDateTimesWithTolerance(2.seconds)\n  )\n  expected\n}\n")),(0,l.kt)("h3",{id:"matchoffsetdatetimeswithtolerance"},"matchOffsetDateTimesWithTolerance"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val expected = WithManyFields(\n      BigDecimal.ONE,\n      LocalDateTime.now(),\n      ZonedDateTime.now(),\n      OffsetDateTime.now(),\n      Instant.now()\n   )\nval actual = expected.copy(offsetDateTime = expected.offsetDateTime.plusSeconds(1))\n\nactual shouldBeEqualUsingFields {\n  overrideMatchers = mapOf(\n     WithManyFields::offsetDateTime to matchOffsetDateTimesWithTolerance(2.seconds)\n  )\n  expected\n}\n")),(0,l.kt)("h3",{id:"matchstringsignoringcase"},"matchStringsIgnoringCase"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'   val expected = SimpleDataClass("apple", 1.0, LocalDateTime.now())\n   val actual = expected.copy(name = "Apple")\n\n   actual shouldBeEqualUsingFields {\n      overrideMatchers = mapOf(\n         SimpleDataClass::name to matchStringsIgnoringCase\n      )\n      expected\n   }\n')),(0,l.kt)("h3",{id:"matchzoneddatetimeswithtolerance"},"matchZonedDateTimesWithTolerance"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val expected = WithManyFields(\n      BigDecimal.ONE,\n      LocalDateTime.now(),\n      ZonedDateTime.now(),\n      OffsetDateTime.now(),\n      Instant.now()\n   )\nval actual = expected.copy(zonedDateTime = expected.zonedDateTime.plusSeconds(1))\n\nactual shouldBeEqualUsingFields {\n  overrideMatchers = mapOf(\n     WithManyFields::zonedDateTime to matchOffsetDateTimesWithTolerance(2.seconds)\n  )\n  expected\n}\n")),(0,l.kt)("h2",{id:"building-your-own-override-matcher"},"Building Your Own Override Matcher"),(0,l.kt)("p",null,"Implement ",(0,l.kt)("inlineCode",{parentName:"p"},"Assertable")," interface:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun interface Assertable {\n   fun assert(expected: Any?, actual: Any?): CustomComparisonResult\n}\n\nsealed interface CustomComparisonResult {\n   val comparable: Boolean\n   data object NotComparable: CustomComparisonResult {\n      override val comparable = false\n   }\n   data object Equal: CustomComparisonResult {\n      override val comparable = true\n   }\n   data class Different(val assertionError: AssertionError): CustomComparisonResult {\n      override val comparable = true\n   }\n}\n")),(0,l.kt)("p",null,"For instance, here is the implementation of ",(0,l.kt)("inlineCode",{parentName:"p"},"matchListsIgnoringOrder"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun<T> matchListsIgnoringOrder() = Assertable { expected: Any?, actual: Any? ->\n   customComparison<List<T>>(expected, actual) { expected: List<T>, actual: List<T> ->\n      actual shouldContainExactlyInAnyOrder expected\n   }\n}\n")),(0,l.kt)("p",null,"We can use any of Kotest's ",(0,l.kt)("inlineCode",{parentName:"p"},"should***")," assertions."))}m.isMDXComponent=!0}}]);