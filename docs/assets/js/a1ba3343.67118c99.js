"use strict";(self.webpackChunkkotestdocs=self.webpackChunkkotestdocs||[]).push([[54524],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},k=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),k=c(n),u=r,h=k["".concat(s,".").concat(u)]||k[u]||p[u]||l;return n?a.createElement(h,i(i({ref:t},d),{},{components:n})):a.createElement(h,i({ref:t},d))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=k;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var c=2;c<l;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}k.displayName="MDXCreateElement"},45892:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const l={id:"lifecycle_hooks",title:"Lifecycle hooks",slug:"lifecycle-hooks.html",sidebar_label:"Lifecycle hooks"},i=void 0,o={unversionedId:"framework/lifecycle_hooks",id:"framework/lifecycle_hooks",title:"Lifecycle hooks",description:"It is extremely common in tests to want to perform some action before and after a test, or before and after all tests in the same file.",source:"@site/docs/framework/lifecycle_hooks.md",sourceDirName:"framework",slug:"/framework/lifecycle-hooks.html",permalink:"/docs/next/framework/lifecycle-hooks.html",draft:!1,editUrl:"https://github.com/kotest/kotest/blob/master/documentation/docs/framework/lifecycle_hooks.md",tags:[],version:"current",frontMatter:{id:"lifecycle_hooks",title:"Lifecycle hooks",slug:"lifecycle-hooks.html",sidebar_label:"Lifecycle hooks"},sidebar:"framework",previous:{title:"Concurrency",permalink:"/docs/next/framework/concurrency6.html"},next:{title:"Introduction",permalink:"/docs/next/framework/extensions/extensions-introduction.html"}},s={},c=[{value:"DSL Methods",id:"dsl-methods",level:2},{value:"Lambda Type-aliases",id:"lambda-type-aliases",level:3},{value:"Method Overrides",id:"method-overrides",level:2},{value:"Available Hooks",id:"available-hooks",level:2},{value:"Test Lifecycle Hooks",id:"test-lifecycle-hooks",level:3},{value:"Spec Lifecycle Hooks",id:"spec-lifecycle-hooks",level:3}],d={toc:c};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"It is extremely common in tests to want to perform some action before and after a test, or before and after all tests in the same file.\nIt is in these ",(0,r.kt)("em",{parentName:"p"},"lifecycle hooks")," that you would perform any setup/teardown logic required for a test."),(0,r.kt)("p",null,"Kotest provides a rich assortment of hooks that can be defined directly inside a spec.\nAt the end of this section is a list of the available hooks and when they are executed."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},"[Advanced Cases]"),(0,r.kt)("p",{parentName:"admonition"},"For more advanced cases, such as writing distributable plugins, re-usable hooks, or for events that take place outside\na spec (such as project-started or project-finished) take a look at ",(0,r.kt)("a",{parentName:"p",href:"/docs/next/framework/extensions/extensions-introduction.html"},"extensions"),".")),(0,r.kt)("p",null,"There are generally two ways to define these hooks in Kotest that are functionally equivalent but different in style.\nPick whichever you and your team prefer."),(0,r.kt)("h2",{id:"dsl-methods"},"DSL Methods"),(0,r.kt)("p",null,"The first is to use the DSL methods available inside a Spec that accept a lambda for the hook logic.\nFor example, we can invoke ",(0,r.kt)("inlineCode",{parentName:"p"},"beforeTest")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"afterTest")," (or others) directly alongside our tests."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'class TestSpec : FreeSpec() {\n  init {\n\n    beforeTest {\n      println("Starting a test $it")\n    }\n\n    afterTest { (test, result) ->\n      println("Finished spec with result $result")\n    }\n\n    "this test" - {\n      "be alive" {\n        println("Johnny5 is alive!")\n      }\n    }\n  }\n}\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"You can use ",(0,r.kt)("inlineCode",{parentName:"p"},"afterProject")," as a DSL method but there is no equivalent ",(0,r.kt)("inlineCode",{parentName:"p"},"beforeProject"),", because by the time the\nframework is at the stage of executing a spec, the project has already started!")),(0,r.kt)("h3",{id:"lambda-type-aliases"},"Lambda Type-aliases"),(0,r.kt)("p",null,"Since these DSL methods accept functions, we can pull out logic to a function and re-use it in several places. The\n",(0,r.kt)("inlineCode",{parentName:"p"},"beforeTest")," hook accepts a function of type ",(0,r.kt)("inlineCode",{parentName:"p"},"suspend (TestCase) -> Unit"),". There are typealiases for each\nof the function signatures to keep your code simple."),(0,r.kt)("p",null,"For example, to create a re-usable ",(0,r.kt)("inlineCode",{parentName:"p"},"beforeTest")," lambda:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val startTest: BeforeTest = {\n   println("Starting a test $it")\n}\n\nclass TestSpec : FreeSpec({\n\n   // used once\n   beforeTest(startTest)\n\n   "test1" { }\n})\n\nclass OtherSpec : FreeSpec({\n\n   // used again\n   beforeTest(startTest)\n\n   "test2" { }\n})\n')),(0,r.kt)("h2",{id:"method-overrides"},"Method Overrides"),(0,r.kt)("p",null,"The second way to create hooks is to override the appropriate function in the Spec. For example, to add\na before-test hook, we can override the ",(0,r.kt)("inlineCode",{parentName:"p"},"beforeTest")," function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'class TestSpec : FreeSpec() {\n\n    override suspend fun beforeTest(testCase: TestCase) {\n        println("Starting a test $testCase")\n    }\n\n    init {\n        "this test" - {\n            "be alive" {\n                println("Johnny5 is alive!")\n            }\n        }\n    }\n}\n')),(0,r.kt)("h2",{id:"available-hooks"},"Available Hooks"),(0,r.kt)("p",null,"Kotest provides callbacks for various test and spec events."),(0,r.kt)("p",null,"To understand all callbacks correctly it's important to have a good understanding of the two possible ",(0,r.kt)("inlineCode",{parentName:"p"},"TestType")," values:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Container")," - a container that can contain other tests"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Test")," - a leaf test that cannot contain nested tests")),(0,r.kt)("h3",{id:"test-lifecycle-hooks"},"Test Lifecycle Hooks"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Callback"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"before-container"),(0,r.kt)("td",{parentName:"tr",align:null},"Invoked directly before each test with type ",(0,r.kt)("inlineCode",{parentName:"td"},"TestType.Container"),", with the ",(0,r.kt)("inlineCode",{parentName:"td"},"TestCase")," instance as a parameter. If the test is marked is skipped, then this callback won't be invoked.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"after-container"),(0,r.kt)("td",{parentName:"tr",align:null},"Invoked immediately after a ",(0,r.kt)("inlineCode",{parentName:"td"},"TestCase")," with type ",(0,r.kt)("inlineCode",{parentName:"td"},"TestType.Container"),", with the ",(0,r.kt)("inlineCode",{parentName:"td"},"TestResult")," of that test. If a test was skipped then this callback will not be invoked.",(0,r.kt)("br",null),(0,r.kt)("br",null),"The callback will execute even if the test fails.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"before-each"),(0,r.kt)("td",{parentName:"tr",align:null},"Invoked directly before each test with type ",(0,r.kt)("inlineCode",{parentName:"td"},"TestType.Test"),", with the ",(0,r.kt)("inlineCode",{parentName:"td"},"TestCase")," instance as a parameter. If the test is marked is skipped, then this callback won't be invoked.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"after-each"),(0,r.kt)("td",{parentName:"tr",align:null},"Invoked immediately after a ",(0,r.kt)("inlineCode",{parentName:"td"},"TestCase")," with type ",(0,r.kt)("inlineCode",{parentName:"td"},"TestType.Test"),", with the ",(0,r.kt)("inlineCode",{parentName:"td"},"TestResult")," of that test. If the test was skipped then this callback will not be invoked.",(0,r.kt)("br",null),(0,r.kt)("br",null),"The callback will execute even if the test fails.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"before-any"),(0,r.kt)("td",{parentName:"tr",align:null},"Invoked directly before each test with any ",(0,r.kt)("inlineCode",{parentName:"td"},"TestType"),", with the ",(0,r.kt)("inlineCode",{parentName:"td"},"TestCase")," instance as a parameter. If the test is marked is skipped, then this callback won't be invoked.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"after-any"),(0,r.kt)("td",{parentName:"tr",align:null},"Invoked immediately after a ",(0,r.kt)("inlineCode",{parentName:"td"},"TestCase")," with any ",(0,r.kt)("inlineCode",{parentName:"td"},"TestType"),", with the ",(0,r.kt)("inlineCode",{parentName:"td"},"TestResult")," of that test. If the test was skipped then this callback will not be invoked.",(0,r.kt)("br",null),(0,r.kt)("br",null),"The callback will execute even if the test fails.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"before-test"),(0,r.kt)("td",{parentName:"tr",align:null},"This callback is an alias for ",(0,r.kt)("inlineCode",{parentName:"td"},"beforeAny"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"after-test"),(0,r.kt)("td",{parentName:"tr",align:null},"This callback is an alias for ",(0,r.kt)("inlineCode",{parentName:"td"},"afterAny"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"before-invocation"),(0,r.kt)("td",{parentName:"tr",align:null},"Invoked before each 'run' of a test, with a flag indicating the iteration number. This callback is useful if you have set a test to have multiple invocations via config and want to do some setup / teardown between runs.",(0,r.kt)("br",null),(0,r.kt)("br",null),"If you are running a test with the default single invocation then this callback is effectively the same as ",(0,r.kt)("inlineCode",{parentName:"td"},"beforeTest"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"after-invocation"),(0,r.kt)("td",{parentName:"tr",align:null},"Invoked after each 'run' of a test, with a flag indicating the iteration number. This callback is useful if you have set a test to have multiple invocations via config and want to do some setup / teardown between runs.",(0,r.kt)("br",null),(0,r.kt)("br",null),"If you are running a test with the default single invocation then this callback is effectively the same as ",(0,r.kt)("inlineCode",{parentName:"td"},"afterTest"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"after-scope"),(0,r.kt)("td",{parentName:"tr",align:null},"Invoked after that particular scope has finished executing. This hook is only invoked once all the nested tests in that scope have completed and will not be executed after each individual test in that scope.")))),(0,r.kt)("p",null,"Notice that ",(0,r.kt)("inlineCode",{parentName:"p"},"before-each")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"before-container")," are constrained to a particular test-type (leaf or container), whereas ",(0,r.kt)("inlineCode",{parentName:"p"},"before-any")," will be invoked for both.\nThe same applies to ",(0,r.kt)("inlineCode",{parentName:"p"},"after-each"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"after-container")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"after-any"),"."),(0,r.kt)("h3",{id:"spec-lifecycle-hooks"},"Spec Lifecycle Hooks"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Callback"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"before-spec"),(0,r.kt)("td",{parentName:"tr",align:null},"Invoked after the Engine instantiates a spec to be used as part of a test execution.",(0,r.kt)("br",null),(0,r.kt)("br",null),"The callback is provided with the ",(0,r.kt)("inlineCode",{parentName:"td"},"Spec")," instance that the test will be executed under.",(0,r.kt)("br",null),(0,r.kt)("br",null),"If a spec is instantiated multiple times - for example, if ",(0,r.kt)("inlineCode",{parentName:"td"},"InstancePerRoot")," isolation mode is used, then this callback will be invoked for each instance created, just before the first test is executed for that spec.",(0,r.kt)("br",null),(0,r.kt)("br",null),"This callback should be used if you need to perform setup each time a new spec instance is created.",(0,r.kt)("br",null),(0,r.kt)("br",null),"This callback runs before any test level hooks functions are invoked.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"after-spec"),(0,r.kt)("td",{parentName:"tr",align:null},"Is invoked after all the tests that are part of a particular spec instance have completed.",(0,r.kt)("br",null),(0,r.kt)("br",null),"If a spec is instantiated multiple times - for example, if ",(0,r.kt)("inlineCode",{parentName:"td"},"InstancePerRoot")," isolation mode is used, then this callback will be invoked for each instantiated spec, after the tests that are applicable to that spec instance have returned.",(0,r.kt)("br",null),(0,r.kt)("br",null),"This callback should be used if you need to perform cleanup after each individual spec instance.",(0,r.kt)("br",null),(0,r.kt)("br",null),"This callback runs after any test level callbacks have been invoked.",(0,r.kt)("br",null),(0,r.kt)("br",null),"In case there is any exception in ",(0,r.kt)("inlineCode",{parentName:"td"},"beforeSpec"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"afterSpec")," will be skipped.")))))}p.isMDXComponent=!0}}]);