"use strict";(self.webpackChunkkotestdocs=self.webpackChunkkotestdocs||[]).push([[50558],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,u=a(e,["components","mdxType","originalType","parentName"]),c=p(n),d=o,k=c["".concat(l,".").concat(d)]||c[d]||h[d]||i;return n?r.createElement(k,s(s({ref:t},u),{},{components:n})):r.createElement(k,s({ref:t},u))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,s=new Array(i);s[0]=c;var a={};for(var l in t)hasOwnProperty.call(t,l)&&(a[l]=t[l]);a.originalType=e,a.mdxType="string"==typeof e?e:o,s[1]=a;for(var p=2;p<i;p++)s[p]=n[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},86528:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>p});var r=n(87462),o=(n(67294),n(3905));const i={id:"shrinking",title:"Shrinking",slug:"property-test-shrinking.html",sidebar_label:"Shrinking"},s=void 0,a={unversionedId:"proptest/shrinking",id:"proptest/shrinking",title:"Shrinking",description:"In property-based testing, the initially found failing case may contain a lot of complexity that does actually cause the test to fail.",source:"@site/docs/proptest/shrinking.md",sourceDirName:"proptest",slug:"/proptest/property-test-shrinking.html",permalink:"/docs/next/proptest/property-test-shrinking.html",draft:!1,editUrl:"https://github.com/kotest/kotest/blob/master/documentation/docs/proptest/shrinking.md",tags:[],version:"current",frontMatter:{id:"shrinking",title:"Shrinking",slug:"property-test-shrinking.html",sidebar_label:"Shrinking"},sidebar:"proptest",previous:{title:"Custom Generators",permalink:"/docs/next/proptest/custom-generators.html"},next:{title:"Statistics",permalink:"/docs/next/proptest/property-test-statistics.html"}},l={},p=[{value:"Shrinking for built-in generators",id:"shrinking-for-built-in-generators",level:2},{value:"Shrinking for custom generators",id:"shrinking-for-custom-generators",level:2}],u={toc:p};function h(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"In property-based testing, the initially found failing case may contain a lot of complexity that does actually cause the test to fail.\nShrinking is the mechanism through which a property-based testing framework can simplify failing cases in order to find out the minimal reproducible case is.\nIn Kotest, the way in which failing cases from ",(0,o.kt)("a",{parentName:"p",href:"/docs/next/proptest/property-test-generators.html"},"generators")," are shrunk is defined by implementations of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Shrinker")," interface.\nBuilt-in generators generally have a default Shrinker defined by the framework, while custom generators can be given a custom Shrinker implementation."),(0,o.kt)("h2",{id:"shrinking-for-built-in-generators"},"Shrinking for built-in generators"),(0,o.kt)("p",null,"Built-in generators (see ",(0,o.kt)("a",{parentName:"p",href:"/docs/next/proptest/property-test-generators-list.html"},"Generators List"),") have a default Shrinker defined by the framework.\nA shrink function takes as input the value that failed the test and returns a list of new values on which Kotest can appy the test.\nThe exact behaviour depends on the data type.\nFor instance, a string could be shrunk by dropping the first or last character while for integers we could decrement or halve the value.\nIn addition, shrink behaviour is defined for edge cases such as an empty string or the integer 0.\nThe shrinking is performed when a test that uses such generator fails."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"Arb.positiveInt().checkAll { i ->\n    calculateProperty(i) shouldBe true\n}\n")),(0,o.kt)("p",null,"If the test fails for one of the generated inputs then the shrinking result is shown:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Property test failed for inputs\n\n0) 1792716902\n\nCaused by io.kotest.assertions.AssertionFailedError: expected:<1792716902> but was:<0> at\n    PropertyBasedTest$1$1$3$1.invokeSuspend(PropertyBasedTest.kt:54)\n    PropertyBasedTest$1$1$3$1.invoke(PropertyBasedTest.kt)\n    PropertyBasedTest$1$1$3$1.invoke(PropertyBasedTest.kt)\n    io.kotest.property.internal.ProptestKt$proptest$3$2.invokeSuspend(proptest.kt:45)\n\nAttempting to shrink arg 1792716902\nShrink #1: 1 pass\nShrink #2: 597572300 fail\nShrink #3: 199190766 fail\nShrink #4: 66396922 fail\nShrink #5: 22132307 fail\nShrink #6: 7377435 fail\nShrink #7: 2459145 fail\n\n[...]\n\nShrink #999: 29948 pass\nShrink #1000: 44922 pass\nShrink #1001: 59896 pass\nShrink #1002: 89839 fail\nShrink result (after 1002 shrinks) => 89839\n\nCaused by io.kotest.assertions.AssertionFailedError: expected:<89839> but was:<0> at\n    PropertyBasedTest$1$1$3$1.invokeSuspend(PropertyBasedTest.kt:54)\n    PropertyBasedTest$1$1$3$1.invoke(PropertyBasedTest.kt)\n    PropertyBasedTest$1$1$3$1.invoke(PropertyBasedTest.kt)\n    io.kotest.property.internal.ShrinkfnsKt$shrinkfn$1$1$smallestA$1.invokeSuspend(shrinkfns.kt:19)\n")),(0,o.kt)("p",null,"By default, Kotest will shrink 1000 times. This behaviour is configurable.\nFor example, if you want to continue shrinking without bounds:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"Arb.positiveInt().checkAll(PropTestConfig(shrinkingMode = ShrinkingMode.Unbounded)) { i ->\n    calculateProperty(i) shouldBe true\n}\n")),(0,o.kt)("p",null,"If you want to configure the behaviour globally, then either modify the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"PropertyTesting.defaultShrinkingMode")," or use the following system properties as in this example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"# If you want to disable shrinking:\nkotest.proptest.default.shrinking.mode=off\n\n# If you want to continue shrinking without bounds:\nkotest.proptest.default.shrinking.mode=unbounded\n\n# If you want to shrink a bounded number of times (e.g. 500):\nkotest.proptest.default.shrinking.mode=bounded\nkotest.proptest.default.shrinking.bound=500\n")),(0,o.kt)("h2",{id:"shrinking-for-custom-generators"},"Shrinking for custom generators"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"/docs/next/proptest/custom-generators.html"},"Custom generators")," do not have a Shrinker defined by Kotest.\nInstead, custom Shrinkers can be implemented.\nBelow is an example where the Shrinker returns coordinates that are next to the value itself."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'data class Coordinate(val x: Int, val y: Int)\n\nclass CoordinateTest : FunSpec({\n    context("Coordinate Transformations") {\n        // Shrinker takes the four neighbouring coordinates\n        val coordinateShrinker = Shrinker<Coordinate> { c ->\n            listOf(\n                Coordinate(c.x - 1, c.y),\n                Coordinate(c.x, c.y - 1),\n                Coordinate(c.x + 1, c.y),\n                Coordinate(c.x, c.y + 1),\n            )\n        }\n        val coordinateArb = arbitrary(coordinateShrinker) {\n            Coordinate(Arb.nonNegativeInt().bind(), Arb.nonNegativeInt().bind())\n        }\n\n        test("Coordinates are always positive after transformation") {\n            coordinateArb.checkAll {\n                transform(it).x shouldBeGreaterThanOrEqualTo 0\n                transform(it).y shouldBeGreaterThanOrEqualTo 0\n            }\n        }\n    }\n})\n')))}h.isMDXComponent=!0}}]);