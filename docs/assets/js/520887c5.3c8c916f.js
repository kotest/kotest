"use strict";(self.webpackChunkkotestdocs=self.webpackChunkkotestdocs||[]).push([[11163],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var o=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),l=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=l(n),m=r,h=d["".concat(c,".").concat(m)]||d[m]||p[m]||i;return n?o.createElement(h,a(a({ref:t},u),{},{components:n})):o.createElement(h,a({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,a=new Array(i);a[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,a[1]=s;for(var l=2;l<i;l++)a[l]=n[l];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},68790:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var o=n(87462),r=(n(67294),n(3905));const i={id:"concurrency6",title:"Concurrency",slug:"concurrency6.html"},a=void 0,s={unversionedId:"framework/concurrency6",id:"version-6.0/framework/concurrency6",title:"Concurrency",description:"This document describes the new concurrency features introduced in Kotest 6.0.",source:"@site/versioned_docs/version-6.0/framework/concurrency6.0.md",sourceDirName:"framework",slug:"/framework/concurrency6.html",permalink:"/docs/6.0/framework/concurrency6.html",draft:!1,editUrl:"https://github.com/kotest/kotest/blob/master/documentation/versioned_docs/version-6.0/framework/concurrency6.0.md",tags:[],version:"6.0",frontMatter:{id:"concurrency6",title:"Concurrency",slug:"concurrency6.html"},sidebar:"framework",previous:{title:"Isolation Modes",permalink:"/docs/6.0/framework/isolation-mode.html"},next:{title:"Lifecycle hooks",permalink:"/docs/6.0/framework/lifecycle-hooks.html"}},c={},l=[{value:"Concurrency Modes",id:"concurrency-modes",level:2},{value:"Spec Concurrency Mode",id:"spec-concurrency-mode",level:3},{value:"Test Concurrency Mode",id:"test-concurrency-mode",level:3},{value:"Project-wide configuration",id:"project-wide-configuration",level:4},{value:"Package-level configuration",id:"package-level-configuration",level:4},{value:"Spec-level configuration",id:"spec-level-configuration",level:4},{value:"Examples",id:"examples",level:2},{value:"Example: Running tests within a spec concurrently",id:"example-running-tests-within-a-spec-concurrently",level:3},{value:"Example: Limited concurrency for tests",id:"example-limited-concurrency-for-tests",level:3},{value:"Example: Combining spec and test concurrency modes",id:"example-combining-spec-and-test-concurrency-modes",level:3},{value:"Coroutine Dispatcher Factory",id:"coroutine-dispatcher-factory",level:2},{value:"How It Works",id:"how-it-works",level:3},{value:"Configuration Options",id:"configuration-options",level:3},{value:"Project-wide configuration",id:"project-wide-configuration-1",level:4},{value:"Spec-level configuration",id:"spec-level-configuration-1",level:4},{value:"Built-in Implementations",id:"built-in-implementations",level:3},{value:"Custom Implementation Example",id:"custom-implementation-example",level:3},{value:"Use Cases",id:"use-cases",level:3},{value:"Blocking Test Mode",id:"blocking-test-mode",level:2},{value:"Example: Using blockingTest mode with timeouts",id:"example-using-blockingtest-mode-with-timeouts",level:3}],u={toc:l};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"This document describes the new concurrency features introduced in Kotest 6.0.\nIf you are using an earlier version of Kotest, please refer to the ",(0,r.kt)("a",{parentName:"p",href:"https://kotest.io/docs/framework/concurrency.html"},"previous concurrency documentation"),".")),(0,r.kt)("p",null,"Concurrency is at the heart of Kotlin, with compiler support for continuations (suspend functions), enabling\nthe powerful coroutines library, in addition to the standard Java concurrency tools."),(0,r.kt)("p",null,"So it is expected that a Kotlin test framework should offer full support for executing tests concurrently,\nwhether that is through traditional blocking calls or suspendable functions."),(0,r.kt)("p",null,"Kotest offers the following features:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ability to launch specs and tests concurrently."),(0,r.kt)("li",{parentName:"ul"},"The ability to specify the coroutine dispatcher used to execute tests."),(0,r.kt)("li",{parentName:"ul"},"The ability to run tests that use blocking APIs on a separate thread just for that test.")),(0,r.kt)("p",null,"These features are orthogonal but complimentary."),(0,r.kt)("p",null,"By default, Kotest will execute each test case sequentially using ",(0,r.kt)("inlineCode",{parentName:"p"},"Dispatchers.Default"),".\nThis means if a test suspends or blocks, the whole test suite will suspend or block until that test resumes."),(0,r.kt)("p",null,"This is the safest default to use, since it places no burden or expectation on the user to write thread-safe tests.\nFor example, tests can share state or use instance fields which are not thread safe. It won't subject your tests to\nrace conditions or require you to know Java's memory model. Specs can use before and after methods confidently knowing\nthey won't interfere with each other."),(0,r.kt)("p",null,"However, some users will want to run tests concurrently to reduce the total execution time of their test suite.\nThis is especially true when testing code that suspends or blocks - the performance gains from allowing tests to run\nconcurrently can be significant."),(0,r.kt)("h2",{id:"concurrency-modes"},"Concurrency Modes"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The concurrency modes described below are only available on the JVM platform.\nOn other platforms, tests will always run sequentially.")),(0,r.kt)("p",null,"Kotest provides two types of concurrency modes:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Spec Concurrency Mode")," - Controls how specs (test classes) are executed in relation to each other"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Test Concurrency Mode")," - Controls how root tests within a spec are executed in relation to each other.")),(0,r.kt)("h3",{id:"spec-concurrency-mode"},"Spec Concurrency Mode"),(0,r.kt)("p",null,"Spec concurrency mode determines whether multiple specs can be executed at the same time. There are three options:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Sequential")," - All specs are executed sequentially (default mode)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Concurrent")," - All specs are executed concurrently"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"LimitedConcurrency(max: Int)")," - Specs are executed concurrently up to a given maximum number")),(0,r.kt)("p",null,"You can configure the spec concurrency mode in your project config:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"class MyProjectConfig : AbstractProjectConfig() {\n    override val specExecutionMode = SpecExecutionMode.Concurrent\n}\n")),(0,r.kt)("p",null,"Or for limited concurrency:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"class MyProjectConfig : AbstractProjectConfig() {\n    override val specExecutionMode = SpecExecutionMode.LimitedConcurrency(4) // Run up to 4 specs concurrently\n}\n")),(0,r.kt)("h3",{id:"test-concurrency-mode"},"Test Concurrency Mode"),(0,r.kt)("p",null,"Test concurrency mode determines whether multiple root tests within a spec can be executed at the same time.\nNote that nested tests (tests defined within other tests) are not affected by this setting; they will always run sequentially."),(0,r.kt)("p",null,"There are three options:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Sequential")," - All tests are executed sequentially (default mode)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Concurrent")," - All tests are executed concurrently"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"LimitedConcurrency(max: Int)")," - Tests are executed concurrently up to a given maximum number")),(0,r.kt)("p",null,"You can configure the test concurrency mode at different levels:"),(0,r.kt)("h4",{id:"project-wide-configuration"},"Project-wide configuration"),(0,r.kt)("p",null,"This will apply for all specs and tests in the project unless overridden at a lower level."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"class MyProjectConfig : AbstractProjectConfig() {\n    override val testExecutionMode = TestExecutionMode.Concurrent\n}\n")),(0,r.kt)("h4",{id:"package-level-configuration"},"Package-level configuration"),(0,r.kt)("p",null,"Package-level configuration allows you to set the test execution mode for all specs in a specific package,\nand is only available on the JVM platform."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"class MyPackageConfig : AbstractPackageConfig() {\n    override val testExecutionMode = TestExecutionMode.Concurrent\n}\n")),(0,r.kt)("h4",{id:"spec-level-configuration"},"Spec-level configuration"),(0,r.kt)("p",null,"You can configure test concurrency mode for a specific spec in two ways:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"By overriding the ",(0,r.kt)("inlineCode",{parentName:"li"},"testExecutionMode()")," function:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"class MySpec : FreeSpec() {\n    override fun testExecutionMode() = TestExecutionMode.Concurrent\n\n    // tests...\n}\n")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"By setting the ",(0,r.kt)("inlineCode",{parentName:"li"},"testExecutionMode")," property:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"class MySpec : FreeSpec() {\n    init {\n        testExecutionMode = TestExecutionMode.Concurrent\n\n        // tests...\n    }\n}\n")),(0,r.kt)("h2",{id:"examples"},"Examples"),(0,r.kt)("h3",{id:"example-running-tests-within-a-spec-concurrently"},"Example: Running tests within a spec concurrently"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'class ConcurrentTestsSpec : FreeSpec({\n\n    // Configure this spec to run tests concurrently\n    testExecutionMode = TestExecutionMode.Concurrent\n\n    "test 1" {\n        // This test will run concurrently with other tests\n        delay(1000)\n        // assertions...\n    }\n\n    "test 2" {\n        // This test will run concurrently with other tests\n        delay(500)\n        // assertions...\n    }\n\n    "test 3" {\n        // This test will run concurrently with other tests\n        delay(200)\n        // assertions...\n    }\n})\n')),(0,r.kt)("h3",{id:"example-limited-concurrency-for-tests"},"Example: Limited concurrency for tests"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"class LimitedConcurrencySpec : FreeSpec({\n    // Configure this spec to run up to 2 tests concurrently\n    testExecutionMode = TestExecutionMode.LimitedConcurrency(2)\n\n    // tests...\n})\n")),(0,r.kt)("h3",{id:"example-combining-spec-and-test-concurrency-modes"},"Example: Combining spec and test concurrency modes"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"class MyProjectConfig : AbstractProjectConfig() {\n    // Run up to 3 specs concurrently\n    override val specExecutionMode = SpecExecutionMode.LimitedConcurrency(3)\n\n    // By default, run tests sequentially within each spec\n    override val testExecutionMode = TestExecutionMode.Sequential\n}\n\n// Override the test execution mode for a specific spec\nclass ConcurrentTestsSpec : FreeSpec({\n    // This spec will run its tests concurrently\n    testExecutionMode = TestExecutionMode.Concurrent\n\n    // tests...\n})\n")),(0,r.kt)("h2",{id:"coroutine-dispatcher-factory"},"Coroutine Dispatcher Factory"),(0,r.kt)("p",null,"Kotest allows you to customize the coroutine dispatcher used for executing specs and tests through the\n",(0,r.kt)("inlineCode",{parentName:"p"},"CoroutineDispatcherFactory")," feature. This gives you fine-grained control over the execution context of your tests."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"CoroutineDispatcherFactory")," interface provides methods to switch the ",(0,r.kt)("inlineCode",{parentName:"p"},"CoroutineDispatcher")," used for:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Spec callbacks (like ",(0,r.kt)("inlineCode",{parentName:"li"},"beforeSpec")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"afterSpec"),")"),(0,r.kt)("li",{parentName:"ol"},"Test case execution")),(0,r.kt)("h3",{id:"how-it-works"},"How It Works"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"CoroutineDispatcherFactory")," interface has two main methods:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"interface CoroutineDispatcherFactory {\n  // For spec callbacks\n  suspend fun <T> withDispatcher(spec: Spec, f: suspend () -> T): T\n\n  // For test case execution\n  suspend fun <T> withDispatcher(testCase: TestCase, f: suspend () -> T): T\n\n  // Closes resources when the test engine completes\n  fun close() {}\n}\n")),(0,r.kt)("p",null,"When a ",(0,r.kt)("inlineCode",{parentName:"p"},"CoroutineDispatcherFactory")," is configured, Kotest will use it to determine which dispatcher to use when\nexecuting specs and tests."),(0,r.kt)("h3",{id:"configuration-options"},"Configuration Options"),(0,r.kt)("p",null,"You can configure a ",(0,r.kt)("inlineCode",{parentName:"p"},"CoroutineDispatcherFactory")," at different levels:"),(0,r.kt)("h4",{id:"project-wide-configuration-1"},"Project-wide configuration"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"class MyProjectConfig : AbstractProjectConfig() {\n    override val coroutineDispatcherFactory = ThreadPerSpecCoroutineContextFactory\n}\n")),(0,r.kt)("h4",{id:"spec-level-configuration-1"},"Spec-level configuration"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"class MySpec : FreeSpec() {\n    // Option 1: Using property\n    init {\n        coroutineDispatcherFactory = ThreadPerSpecCoroutineContextFactory\n\n        // tests...\n    }\n\n    // Option 2: Using function\n    override fun coroutineDispatcherFactory() = ThreadPerSpecCoroutineContextFactory\n}\n")),(0,r.kt)("h3",{id:"built-in-implementations"},"Built-in Implementations"),(0,r.kt)("p",null,"Kotest provides a built-in implementation called ",(0,r.kt)("inlineCode",{parentName:"p"},"ThreadPerSpecCoroutineContextFactory")," that creates a dedicated thread\nper spec."),(0,r.kt)("p",null,"This implementation:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Creates a dedicated thread for each spec"),(0,r.kt)("li",{parentName:"ul"},"Uses that thread as the coroutine dispatcher for the spec and all its tests"),(0,r.kt)("li",{parentName:"ul"},"Shuts down the thread when the spec completes")),(0,r.kt)("h3",{id:"custom-implementation-example"},"Custom Implementation Example"),(0,r.kt)("p",null,"You can create your own custom implementation to suit your specific needs:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"object CustomDispatcherFactory : CoroutineDispatcherFactory {\n\n   // A fixed thread pool with 4 threads\n   private val dispatcher = Executors.newFixedThreadPool(4).asCoroutineDispatcher()\n\n   override suspend fun <T> withDispatcher(spec: Spec, f: suspend () -> T): T {\n      return withContext(dispatcher) {\n         f()\n      }\n   }\n\n   override suspend fun <T> withDispatcher(testCase: TestCase, f: suspend () -> T): T {\n      return withContext(dispatcher) {\n         f()\n      }\n   }\n\n   override fun close() {\n      dispatcher.close()\n   }\n}\n")),(0,r.kt)("h3",{id:"use-cases"},"Use Cases"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"coroutineDispatcherFactory")," feature is useful for:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Performance optimization"),": Using a dedicated thread per spec can improve performance by reducing context switching"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Resource isolation"),": Ensuring each spec runs on its own thread can help isolate tests from each other"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Custom threading models"),": Implementing specific threading strategies for your test suite"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Testing with specific dispatchers"),": Testing code that behaves differently on different dispatchers")),(0,r.kt)("h2",{id:"blocking-test-mode"},"Blocking Test Mode"),(0,r.kt)("p",null,"When working with blocking code in tests, you may encounter issues with timeouts not working as expected.\nThis is because coroutine timeouts are cooperative by nature, meaning they rely on the coroutine\nto yield control back to the scheduler."),(0,r.kt)("p",null,"To address this issue, Kotest provides a ",(0,r.kt)("inlineCode",{parentName:"p"},"blockingTest")," mode that can be enabled on a per-test basis:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'"test with blocking code" {\n    // Enable blocking test mode for this test\n    blockingTest = true\n\n    // Your test with blocking code...\n    Thread.sleep(1000) // Example of blocking code\n}\n')),(0,r.kt)("p",null,"When ",(0,r.kt)("inlineCode",{parentName:"p"},"blockingTest")," is set to true:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Execution will switch to a dedicated thread for the test case"),(0,r.kt)("li",{parentName:"ul"},"This allows the test engine to safely interrupt tests via Thread.interrupt when they time out"),(0,r.kt)("li",{parentName:"ul"},"Other tests can continue running concurrently if configured to do so")),(0,r.kt)("h3",{id:"example-using-blockingtest-mode-with-timeouts"},"Example: Using blockingTest mode with timeouts"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'class BlockingTestSpec : FreeSpec({\n    "test with timeout and blocking code".config(blockingTest = true, timeout = 500.milliseconds) {\n        // This blocking call would normally prevent the timeout from working\n        // With blockingTest = true, the test will be interrupted after 500ms\n        Thread.sleep(1000)\n    }\n})\n')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"blockingTest")," mode is only necessary when you're using blocking calls in your tests.\nFor tests that use suspending functions, the regular timeout mechanism works fine without needing to enable this mode.")))}p.isMDXComponent=!0}}]);