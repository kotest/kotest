"use strict";(self.webpackChunkkotestdocs=self.webpackChunkkotestdocs||[]).push([[13636],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,h=d["".concat(l,".").concat(m)]||d[m]||p[m]||i;return n?r.createElement(h,o(o({ref:t},u),{},{components:n})):r.createElement(h,o({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},46100:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var r=n(87462),a=(n(67294),n(3905));const i={id:"until",title:"Until",slug:"until.html"},o=void 0,s={unversionedId:"assertions/until",id:"assertions/until",title:"Until",description:'When testing non-deterministic code, a common use case is "I expect this code to pass after a short period of time".',source:"@site/docs/assertions/until.md",sourceDirName:"assertions",slug:"/assertions/until.html",permalink:"/docs/next/assertions/until.html",draft:!1,editUrl:"https://github.com/kotest/kotest/blob/master/documentation/docs/assertions/until.md",tags:[],version:"current",frontMatter:{id:"until",title:"Until",slug:"until.html"},sidebar:"framework",previous:{title:"Continually",permalink:"/docs/next/assertions/continually.html"},next:{title:"Retry",permalink:"/docs/next/assertions/retry.html"}},l={},c=[{value:"Duration",id:"duration",level:3},{value:"Interval",id:"interval",level:3}],u={toc:c};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,'When testing non-deterministic code, a common use case is "I expect this code to pass after a short period of time".'),(0,a.kt)("p",null,"For example, you might want to test that a message has been received by a broker. You could setup a time limit,\nand repeatedly poll until the message was received, but this would block the thread. Plus you would have to write\nthe loop code, adding boilerplate."),(0,a.kt)("p",null,"As an alternative, kotest provides the ",(0,a.kt)("inlineCode",{parentName:"p"},"until")," function which will periodically execute a function until either that\nfunction returns true, or the given duration expires."),(0,a.kt)("p",null,"Until is the predicate equivalent of ",(0,a.kt)("a",{parentName:"p",href:"/docs/next/assertions/eventually.html"},"eventually"),"."),(0,a.kt)("h3",{id:"duration"},"Duration"),(0,a.kt)("p",null,"Let's say we have a function that polls a broker, and returns a list of messages. We want to test that when we\nsend a message the message is picked up by the broker within 5 seconds."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'class MyTests : ShouldSpec() {\n\n  private val broker = createBrokerClient()\n\n  init {\n    should("broker should receive a message") {\n      sendMessage()\n      until(5.seconds) {\n        broker.poll().size > 0\n      }\n    }\n  }\n}\n')),(0,a.kt)("h3",{id:"interval"},"Interval"),(0,a.kt)("p",null,"By default, the predicate is checked every second. We can specify an interval which controls the delay between invocations.\nHere is the same example again, this time with a more aggressive fixed 250 millisecond interval."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'class MyTests : ShouldSpec() {\n\n  private val broker = createBrokerClient()\n\n  init {\n    should("broker should receive a message") {\n      sendMessage()\n      until(5.seconds, 250.milliseconds.fixed()) {\n        broker.poll().size > 0\n      }\n    }\n  }\n}\n')),(0,a.kt)("p",null,"We can also specify a fibonacci interval, if we want to increase the delay after each failure."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'class MyTests : ShouldSpec() {\n\n  private val broker = createBrokerClient()\n\n  init {\n    should("broker should receive a message") {\n      sendMessage()\n      until(5.seconds, 100.milliseconds.fibonacci()) {\n        broker.poll().size > 0\n      }\n    }\n  }\n}\n')))}p.isMDXComponent=!0}}]);