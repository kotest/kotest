"use strict";(self.webpackChunkkotestdocs=self.webpackChunkkotestdocs||[]).push([[29249],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=c(n),d=r,m=p["".concat(l,".").concat(d)]||p[d]||h[d]||o;return n?a.createElement(m,s(s({ref:t},u),{},{components:n})):a.createElement(m,s({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},96480:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const o={id:"custom_matchers",title:"Custom Matchers",slug:"custom-matchers.html",sidebar_label:"Custom Matchers"},s=void 0,i={unversionedId:"assertions/custom_matchers",id:"assertions/custom_matchers",title:"Custom Matchers",description:"It is easy to define your own matchers in Kotest.",source:"@site/docs/assertions/custom.md",sourceDirName:"assertions",slug:"/assertions/custom-matchers.html",permalink:"/docs/next/assertions/custom-matchers.html",draft:!1,editUrl:"https://github.com/kotest/kotest/blob/master/documentation/docs/assertions/custom.md",tags:[],version:"current",frontMatter:{id:"custom_matchers",title:"Custom Matchers",slug:"custom-matchers.html",sidebar_label:"Custom Matchers"},sidebar:"assertions",previous:{title:"Should Be",permalink:"/docs/next/assertions/shouldbe.html"},next:{title:"Composed Matchers",permalink:"/docs/next/assertions/composed-matchers.html"}},l={},c=[{value:"Click to view difference",id:"click-to-view-difference",level:2},{value:"Extension Variants",id:"extension-variants",level:2}],u={toc:c};function h(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"It is easy to define your own matchers in Kotest."),(0,r.kt)("p",null,"Simply extend the ",(0,r.kt)("inlineCode",{parentName:"p"},"Matcher<T>")," interface, where T is the type you wish to match against. The ",(0,r.kt)("inlineCode",{parentName:"p"},"Matcher")," interface\nspecifies one method, ",(0,r.kt)("inlineCode",{parentName:"p"},"test")," which returns an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"MatcherResult"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"interface Matcher<in T> {\n  fun test(value: T): MatcherResult\n}\n")),(0,r.kt)("p",null,"This ",(0,r.kt)("inlineCode",{parentName:"p"},"MatcherResult")," type defines three methods - a boolean to indicate if the test passed or failed, and two failure\nmessages."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"interface MatcherResult {\n  fun passed(): Boolean\n  fun failureMessage(): String\n  fun negatedFailureMessage(): String\n}\n")),(0,r.kt)("p",null,"The first failure message is the message to the user if the matcher predicate failed. Usually you can include some\ndetails of the expected value and the actual value and how they differed. The second failure message is the message to\nthe user if the matcher predicate evaluated true in ",(0,r.kt)("em",{parentName:"p"},"negated")," mode. Here you usually indicate that you expected the\npredicate to fail."),(0,r.kt)("p",null,"The difference in those two messages will be clearer with an example. Let's consider writing a length matcher for\nString's, to assert that a string has a required length. We will want our syntax to be something\nlike ",(0,r.kt)("inlineCode",{parentName:"p"},"str.shouldHaveLength(8)"),"."),(0,r.kt)("p",null,"Then the first message should be something like ",(0,r.kt)("inlineCode",{parentName:"p"},'"string had length 15 but we expected length 8"'),". The second message\nwould need to be something like ",(0,r.kt)("inlineCode",{parentName:"p"},'"string should not have length 8"')),(0,r.kt)("p",null,"First, we build out our matcher type. Note, don't create an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"MatcherResult")," directly, instead use the\n",(0,r.kt)("inlineCode",{parentName:"p"},"MatcherResultBuilder")," builder function which will return an appropriate concrete type for your platform."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'fun haveLength(length: Int) = Matcher<String> { value ->\n  MatcherResult(\n    value.length == length,\n    { "string had length ${value.length} but we expected length $length" },\n    { "string should not have length $length" },\n  )\n}\n')),(0,r.kt)("p",null,"Notice that we wrap the error messages in a function call so we don't evaluate if not needed. This is important for\nerror messages that take some time to generate."),(0,r.kt)("p",null,"This matcher can then be passed to the ",(0,r.kt)("inlineCode",{parentName:"p"},"should")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"shouldNot")," infix functions as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'"hello foo" should haveLength(9)\n"hello bar" shouldNot haveLength(3)\n')),(0,r.kt)("h2",{id:"click-to-view-difference"},"Click to view difference"),(0,r.kt)("p",null,"When returning a ",(0,r.kt)("inlineCode",{parentName:"p"},"MatcherResult")," from a matcher, if you supply an expected and actual value to the\n",(0,r.kt)("inlineCode",{parentName:"p"},"MatcherResultBuilder")," then the failure messages will include a clickable diff inside IntelliJ."),(0,r.kt)("h2",{id:"extension-variants"},"Extension Variants"),(0,r.kt)("p",null,"Usually, we want to define extension functions which invoke the matcher function for you and return the original value\nfor chaining. This is how Kotest structures the built-in matchers, and Kotest adopts a shouldXYZ naming strategy. For\nexample:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun String.shouldHaveLength(length: Int): String {\n  this should haveLength(length)\n  return this\n}\n\nfun String.shouldNotHaveLength(length: Int): String {\n  this shouldNot haveLength(length)\n  return this\n}\n")),(0,r.kt)("p",null,"Then we can invoke these like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'"hello foo".shouldHaveLength(9)\n"hello bar".shouldNotHaveLength(3)\n')))}h.isMDXComponent=!0}}]);